# 如何使用 Node.js 进行服务端编程

## 使用 `net` 模块实现 TCP 服务

使用 `net` 模块实现 TCP 服务需要解析 HTTP 请求内容，并根据 HTTP 协议规范组织响应内容。

- [相关示例](./tcp-server.js)

## 使用 `http` 模块实现 HTTP 服务

使用 `http` 模块可以直接使用回调函数的 `req` 和 `res` 对象处理请求和响应。

- [相关示例](./http-simple.js)

### HTTP 内容协商

客户端发送带有 `Accept-*` 请求头的的请求，服务端返回不同的响应内容。

- [相关示例](./http-consult.js)

### HTTP 缓存控制

HTTP 缓存控制可以将网络资源缓存起来，这样能大大节省带宽，提高网页加载速度。是 Web 服务性能优化的重要手段之一。

#### 强缓存

**强缓存**指的是服务端返回一个带有 `Cache-Control` 响应头的响应，客户端根据该字段的值直接进行缓存控制。

如果客户端使用了缓存，在工具栏的 Network 选项中，Size 列的会显示 `(memory cache)`，表示客户端直接使用缓存的内容，并未向服务端发送请求。

如果通过浏览器地址栏访问（请求头会带有 `Cache-Control: max-age=0`）资源或者强制刷新网页获取资源（请求头会带有 `Cache-Control: no-cache` 和 `Pragma: no-cache` 字段），浏览器不会使用强缓存的资源，而是直接使用服务端响应的新资源。

- [相关示例](./http-cache-control.js)

#### 协商缓存

**协商缓存**指的是客户端和服务端通过内容协商实现的缓存机制。协商缓存可以缓存通过地址栏访问的资源，并且在资源更新时可以及时获取最新资源，而不需要强制刷新重新获取资源。如果协商缓存生效，客户端仍会发送请求，但会返回一个状态码为 304 的并且只有响应头没有实体的响应。

协商缓存根据**资源修改时间**和**资源内容变更**来进行缓存控制。

第一种协商缓存的原理是，如果服务端响应时带有 `Last-Modified` 响应头字段，它的值是一个时间戳（资源最后修改的时间）。客户端收到该响应会将资源缓存，在以后的请求中都会带有 `if-modified-since` 请求头字段，它的值是上一次响应中 `Last-Modified` 字段的值。服务端收到带有 `if-modified-since` 字段的的请求后，通过比较该字段的值与资源最后一次修改的时间，如果相等，会返回一个状态码为 304 的响应，该响应只有响应头而没有实体；如果不等，说明资源已经被修改，则会返回一个状态码为 200 且具有最新资源的响应。客户端如果收到状态码为 304 的响应，会以缓存的内容作为实体。

- [相关示例](./http-last-modified.js)

第二种与第一种协商缓存的原理基本相同，服务端响应带有 `Etag` 资源签名字段，客户端请求带有 `If-None-Match` 条件请求。第二种协商缓存用于分布式部署的情况，避免同步资源时各副本修改时间不同而导致的缓存失效问题。

- [相关示例](./http-etag.js)

### HTTP 文件压缩

使用 HTTP 对文件进行压缩可以大大节省传输带宽，提升请求响应速度，减少页面访问延迟。是 Web 服务性能优化的重要手段之一。

客户端会将支持的压缩格式放入 `Accept-Encoding` 请求头字段中，服务端会选择一种压缩算法放入 `Content-Encoding` 响应头字段中，并返回压缩后的资源。客户端可以根据服务端指定的压缩算法自动进行解压。

通常只对 HTML、CSS 和 JS 等资源进行压缩，而图片、音频和视频等文件通常已经压缩过，再进行压缩可能适得其反。

- [相关示例](./http-compression.js)

本项目基于掘金小册[从前端到全栈]（https://juejin.cn/book/7133100888566005763?scrollMenuIndex=0）实现。

